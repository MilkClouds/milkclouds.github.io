---
layout: post
title: '[ 알고리즘 ] 동적 계획법(Dynamic Programming)'
author: MilkClouds
comments: true
date: 2019-02-24 17:26
tags: [algorithm]

---


### 개요  
다이나믹 프로그래밍, DP라는 것은 입문은 쉬운 편인데 중급 정도 문제는 쉽지는 않네? 같은 감상이다가 심화로 가면 한없이 어려워지는 기법이다. 활용하면 워낙 강력하기도 하고 관련 문제도 많아서 상당히 중요하다.


### 동적 계획법  
특정 범위까지의 답을 구하기 위해 그 전 범위까지의 문제의 답을 가져와 씀으로써 효율적으로 답을 구하는 기법이다. 분할 정복과 비슷하게, 주어진 문제를 부분 문제를 나누어 부분 문제의 답을 계산하고 이를 기반으로 원래 문제의 답을 얻는다.


대표적으로 동적 계획법이 사용되는 예로는 `피보나치 수열 구하기`가 있다.
`fibo[0]=fibo[1]=1`이고, `fibo[n]=fibo[n-1]+fibo[n-2] (n>=2)`로 정의하자. 그러면 `fibo[30]`을 구하는 소스를 동적 계획법 없이 짜보자. 이 때, 얼마나 많이 함수가 호출되는지 확인하기 위해 `callCount` 배열에 `fibo(n)`을 호출한 횟수를 기록한다.

```python
callCount=[0]*31

def fibo(n):
    callCount[n]+=1
    if n in (0,1):
        return 1
    return fibo(n-1)+fibo(n-2)

print(fibo(30))
print(callCount)
```

위 소스를 실행한 결과는 아래와 같다. `1346269
[514229, 832040, 514229, 317811, 196418, 121393, 75025, 46368, 28657, 17711, 10946, 6765, 4181, 2584, 1597, 987, 610, 377, 233, 144, 89, 55, 34, 21, 13, 8, 5, 3, 2, 1, 1]`  

`fibo(1)`은 무려 80만번이나 실행됨을 알 수 있다. 이는 n 값이 작아질 수록 `fibo(n)`은 더욱 많이 호출되기 때문이다.(n이 0일 때는 예외다. `fibo(1)`에서 1을 반환하며 원래 `fibo(0)`를 호출해야 하는 횟수가 줄어들기 때문이다.)  

![fibo](https://blogfiles.pstatic.net/20160801_275/kks227_14700305083805XBuM_GIF/complexityRecursion_1.gif)

위 그림을 봤을 때 `f(1)`이 호출되는 횟수가 많음을 알 수 있다.


한 번 동적 계획법을 사용하여 소스를 짜보자. 아래와 같다.

```python
fibo=[0]*51

fibo[0]=fibo[1]=1
for i in range(2,51):
    fibo[i]=fibo[i-1]+fibo[i-2]

print(fibo)
```

`fibo(n)`을 구하는 시간 복잡도가 `O(n)`으로 바뀌었다. 훨씬 빨라진 것을 알 수 있다.  

참고로 피보나치 수열의 n번째 항을 구하는 방법은 일반항을 이용하여 `O(1)`에 구하는 방법, 행렬의 거듭제곱을 이용하여 `O(logn)`에 구하는 방법 등 다양하다. 이 글에서는 적지 않겠지만 검색하면 쉽게 찾을 수 있다.


#### 문제  
[BOJ 11726 2×n 타일링](https://icpc.me/11726)  
[BOJ 1463 1로 만들기](https://icpc.me/1463)  
[BOJ 단계별로 풀어보기 동적 계획법 기초](https://www.acmicpc.net/step/16)