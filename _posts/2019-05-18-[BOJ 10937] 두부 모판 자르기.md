---
layout: post
title: '[BOJ 10937] 두부 모판 자르기'
author: milkclouds
comments: true
date: 2019-05-18 13:09
tags: [boj, problem-solving, c++, koi]

---

## 문제
[https://www.acmicpc.net/problem/13302](https://www.acmicpc.net/problem/13302)  
KOI 2016 고등부 1번

## 사용 알고리즘  
DP   


## 시간 복잡도  
생략 


## 설명  
`dp[day][coupon]=day 번째 날에 쿠폰이 coupon개 있는 경우의 수`
점화식만 잘 세우자. 하루만 지날 때는 쿠폰이 있다면 쓰는 쪽이 좋다.   


### 소스  

```cpp

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
const int price[4][4]={{100,70,40,0},{70,50,30,0},{40,30,20,0},{0,0,0,0}};
int dubu[625],N,final;
ll dp[200][1<<12];
string tmp[25];
int f(int cur,int bit){
    if(cur==final)return 0;
    if(~dp[cur][bit])return dp[cur][bit];
    if(bit&1)return dp[cur][bit]=f(cur+1,bit>>1);
    int ret=0;
    // 1. lower dubu check
    if(cur<N*(N-1))
        ret=max(ret, f(cur+1,(bit>>1)|(1<<N-1))+price[dubu[cur]][dubu[cur+N]]);
    // 2. right dubu check
    if(!(bit&2) && cur%N<N-1){
        ret=max(ret, f(cur+1,(bit>>1)|1)+price[dubu[cur]][dubu[cur+1]]);
    }
    // 3. no dubu
    ret=max(ret, f(cur+1,bit>>1));
    return dp[cur][bit]=ret;
}
int main(){
    cin>>N;
    fill(dp[0],dp[N*N],-1);
    for(int i=0;i<N;i++){
        cin>>tmp[i];
        for(int j=0;j<N;j++)dubu[i*N+j]=tmp[i][j]!='F'?tmp[i][j]-'A':3;
    }
    final=N*N;
    cout<<f(0,0);
}

```