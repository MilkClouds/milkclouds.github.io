---
layout: post
title: '[ 알고리즘 ] 시간 복잡도 이론'
author: MilkClouds
comments: true
date: 2019-02-20 13:46
tags: [algorithm]

---


### 개요  
알고리즘 공부를 처음 시작하는 사람들을 위해, 그리고 나의 개념 정리를 위해 알고리즘 설명 글을 처음부터 써보려고 한다. 시작은 역시 프로그래밍에서 기본이 되는 시간 복잡도 이론으로 하려고 한다.


### 시간 복잡도  
컴퓨터 프로그램의 입력값과, 연산 수행 시간의 상관관계를 나타내는 척도이다. 일반적으로 점근 표기법을 이용해서 나타내는데, 보통 그 중 빅오 표기법을 쓰지만 엄밀히는 상황에 따라 표기법이 다르다.  

+ 최선의 경우: 빅-Ω 표기법(Big-Omega Notation)  
+ 평균의 경우: 빅-Θ 표기법(Big-Theta Notation)  
+ 최악의 경우: 빅-O 표기법(Big-O Notation)  


이 포스트에서는 이 셋의 분류를 엄밀히 하지는 않을 것이다.


### 빅오 표기법  
예를 들면 아래와 같은 프로그램이 있다고 하자.  

```python
ans=0
for i in range(N):
    ans+=i
print(ans)
```

위는 0에서 N-1까지의 합을 구하는 소스이다. N이 1이면 1번, N이 10이면 10번 연산이 필요하다. N의 크기에 따라 연산량이 그대로 바뀌므로 시간 복잡도는 `O(N)`이라 표기한다.


```python
for i in range(1,N+1):
    for j in range(1,N+1):
        print("%d*%d=%d"%(i,j,i*j))
```

위는 `1*1`부터 `N*N`까지의 구구단을 출력하는 소스다. N이 1이면 1번, N이 5번 25번 곱셈과 출력을 한다. 출력은 보통 계산량으로 세지는 않으므로 곱셈만 세자면 `N^2`번 계산을 한다고 할 것이다. 시간 복잡도는 `O(N^2)`이라고 한다.  


이런 식으로, 계산이 입력의 크기에 상관없이 무조건 1번 필요하면 `O(1)`, `logN`번 필요하면 `O(logN)`, `n!`번 필요하면 `O(n!)`이라고 한다.  


그런데 빅오표기법을 사용할 때 여기에 추가으로 알아야 할 점이 2가지 있다.  
1. 최대 차수보다 작은 차수의 항은 생략한다.  
2. 최대 차수의 계수는 생략한다.  

이유는, 예를 들어 `O(N^2+N)`의 시간 복잡도를 가진 소스가 있다고 할 때, 전체 연산량은 `N` 항 보다는 `N^2` 항에 좌우된다. `N^2`의 커지는 정도가 `N`을 빠르게 넘어서기 때문에 `N`의 영향력이 묻혀버리기 때문이다.  

계수를 생략하는 이유 역시 마찬가지다. 중요한 것은 계수가 얼마나 붙냐가 아니라 최대 차수가 얼마이냐이다.


### 시간 복잡도가 중요한 이유  
`O(N^3)`의 프로그램과 `O(N)`의 프로그램이 있으면, 입력 N이 1000만 되도 연산량 차이는 1000000배 난다. 미리 시간 복잡도를 계산하여 프로그램의 실행 시간을 예측할 수도 있고, 시간 복잡도에 대해 제대로 이해하고 있어서 시간 복잡도가 작은 소스를 대신해 쓰면 프로그램의 실행 시간이 엄청나게 차이날 수 있다.  

예를 들면 이분 탐색과 선형 탐색이 그렇다.  
검색 엔진이 자신의 서버에서 데이터를 탐색하여 사용자가 원하는 데이터를 가져다 줄 때, 데이터를 처음부터 차례대로 탐색하면(선형 탐색) 서버 전체 데이터가 N개일때 `O(N)`이 걸린다. 당연히 검색 엔진의 데이터 서버에는 데이터가 굉장히 많을 것이고 오랜 시간이 걸릴 것이다.  

하지만 이분 탐색을 사용하여 `O(logN)`시간만에 탐색을 완료한다면 N이 10억일지라도 계산은 약 30번에 끝난다. (대부분 컴퓨터 프로그램에서 log의 밑은 2이다.)  

사용자가 원하는 데이터를 탐색하여 보여주는 시간이 극명히 차이날 수밖에 없을 것이다.  

